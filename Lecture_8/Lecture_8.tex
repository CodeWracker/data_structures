\documentclass[12pt,table,xcolor={dvipsnames}]{beamer}
\usetheme{Pittsburgh}
\usecolortheme{seagull}
%\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage[brazilian]{babel}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{calc,shapes.multipart,chains,arrows, positioning}
\usepackage{multirow}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{lstlinebgrd}
\usepackage{graphicx}
\subtitle{Pilhas e Filas}
\title{Estruturas de Dados}
%\setbeamercovered{transparent}
\setbeamertemplate{navigation symbols}{}
%\logo{\includegraphics[scale=0.015]{Brasao_UFSC.png}\includegraphics[scale=0.2]{brasao_PPGCC.jpg}}
\institute{Departamento de Computação \\ Prof. Martín Vigil \\ Adaptado de Prof. Jean Everson Martina e Prof. Aldo von Wangenheim}
\date{2020.1}
\subject{}
\usebackgroundtemplate{\includegraphics[width=\paperwidth,
height=\paperheight]{../reusable_images/fundo_UFSC.png}}
\begin{document}

{
\usebackgroundtemplate{\includegraphics[width=\paperwidth,
height=\paperheight]{../reusable_images/fundo_capa.png}}
\begin{frame}
\titlepage
%\includegraphics[scale=0.3]{../reusable_images/brasao_INE.png}
\end{frame}
}

\begin{frame}[fragile]{Extensões do conceito de Lista Encadeada}
\begin{itemize}
\item A idéia da Lista Encadeada vista até agora é o modelo mais geral e simples;
\item Pode ser especializada e estendida das mais variadas formas;
\item Especializada:
\begin{itemize}
\item Pilhas;
\item Filas;
\end{itemize}
\item Estendida:
\begin{itemize}
\item Listas Duplamente Encadeadas;
\item Listas Circulares Simples e Duplas.
\end{itemize}
\end{itemize}
\end{frame}



%%%%
\begin{frame}[fragile]{Conceito de Pilhas}
	\setbeamercovered{invisible}
	\begin{columns}
		\column{.5\textwidth}

	
	\begin{block}{Pilha}
		É uma estrutura de dados cujo funcionamento é inspirado no conceito “natural” de empilhar, onde o \textcolor{blue}{primeiro a entrar é o último a sair} (LIFO = \textit{last in, first out}).
	\end{block}
	
	
		\column{.5\textwidth}
		\begin{center}
			\begin{tikzpicture}[list/.style={rectangle,
				draw=black, fill=green!5,minimum width=0.75cm,
				minimum height = .5cm}, >=stealth, start chain]
			
			\node<1-13>[list,on chain]  (B1)  {};
			\node<1-13>[list,on chain] (B2) [below =0cm of B1] {};
			\node<1-13>[list,on chain] (B3)  [below =0cm of B2] {};
			\node<1-13>[list,on chain] (B4)  [below =0cm of B3] {};
			\node<1-13>[list,on chain] (B5) [below =0cm of B4] {};
			\node<1,13>[] (PV) [above= of B1] {Pilha Vazia};
			
			\node<2>[] (C1) [above left= of B1] {Empilhar 20};
			\draw<2>[->] (C1.east) to [out=45, in=90] (B5.center);
			
			\node<3-12>[list,on chain] (B5) [below =0cm of B4] {20};
			\node<3>[] (C1) [above left= of B1] {Empilhar 55};
			\draw<3>[->] (C1.east) to [out=45, in=90] (B4.center);
			
			\node<4-11>[list,on chain] (B4) [below =0cm of B3] {55};
			\node<4>[] (C1) [above left= of B1] {Empilhar 4};
			\draw<4>[->] (C1.east) to [out=45, in=90] (B3.center);

			\node<5-10>[list,on chain] (B3) [below =0cm of B2] {4};
			\node<5>[] (C1) [above left= of B1] {Empilhar 12};
			\draw<5>[->] (C1.east) to [out=45, in=90] (B2.center);

			\node<6-9>[list,on chain] (B2) [below =0cm of B1] {12};
			\node<6>[] (C1) [above left= of B1] {Empilhar 7};
			\draw<6>[->] (C1.east) to [out=45, in=90] (B1.center);

			\node<7-8>[list,on chain] (B1) [above =0cm of B2] {7};
			\node<8>[] (D1) [above right= of B1] {Desempilhar 7};
			\draw<8>[->] (B1.north) to [out=90, in=180] (D1.west);
			
			\node<9>[] (D1) [above right= of B1] {Desempilhar 12};
			\draw<9>[->] (B2.north) to [out=90, in=180] (D1.west);
			
			\node<10>[] (D1) [above right= of B1] {Desempilhar 4};
			\draw<10>[->] (B3.north) to [out=90, in=180] (D1.west);
			
			\node<11>[] (D1) [above right= of B1] {Desempilhar 55};
			\draw<11>[->] (B4.north) to [out=90, in=180] (D1.west);			
			
			\node<12>[] (D1) [above right= of B1] {Desempilhar 20};
			\draw<12>[->] (B5.north) to [out=90, in=180] (D1.west);			

			\end{tikzpicture}
		\end{center}
	\end{columns}
\end{frame}

%%%%



\begin{frame}<0>[fragile]{Pilhas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}  & &\\ \cline{1-1}
\cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}   & &\\ \cline{1-1}
\cellcolor{SpringGreen}  & &\\ \cline{1-2}
\cellcolor{GreenYellow}  & \multicolumn{1}{|p{.5cm}|} {int} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}<0>[fragile]{Pilhas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\item {\color{red} Pilha Vazia!}
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}  & &\\ \cline{1-1}
\cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}   & &\\ \cline{1-1}
\cellcolor{SpringGreen}  & &\\ \cline{1-2}
\cellcolor{GreenYellow}  & \multicolumn{1}{|p{.5cm}|} {-1} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}<0>[fragile]{Pilhas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}  & &\\ \cline{1-1}
\cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}   & &\\ \cline{1-1}
\cellcolor{SpringGreen}  & &\\ \cline{1-2}
\cellcolor{GreenYellow} 20 & \multicolumn{1}{|p{.5cm}|} {0} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}<0>[fragile]{Pilhas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}  & &\\ \cline{1-1}
\cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}   & &\\ \cline{1-1}
\cellcolor{SpringGreen} 55 & &\\ \cline{1-2}
\cellcolor{GreenYellow} 20 & \multicolumn{1}{|p{.5cm}|} {1} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}<0>[fragile]{Pilhas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}  & &\\ \cline{1-1}
\cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}  4 & &\\ \cline{1-1}
\cellcolor{SpringGreen} 55 & &\\ \cline{1-2}
\cellcolor{GreenYellow} 20 & \multicolumn{1}{|p{.5cm}|} {2} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}<0>[fragile]{Pilhas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}  & &\\ \cline{1-1}
\cellcolor{SpringGreen}  12& &\\ \cline{1-1}
\cellcolor{GreenYellow}  4 & &\\ \cline{1-1}
\cellcolor{SpringGreen} 55 & &\\ \cline{1-2}
\cellcolor{GreenYellow} 20 & \multicolumn{1}{|p{.5cm}|} {3} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}<0>[fragile]{Pilhas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}  89& &\\ \cline{1-1}
\cellcolor{SpringGreen}  12& &\\ \cline{1-1}
\cellcolor{GreenYellow}  4 & &\\ \cline{1-1}
\cellcolor{SpringGreen} 55 & &\\ \cline{1-2}
\cellcolor{GreenYellow} 20 & \multicolumn{1}{|p{.5cm}|} {4} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}<0>[fragile]{Pilhas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen} 24 & &\\ \cline{1-1}
\cellcolor{GreenYellow}  89& &\\ \cline{1-1}
\cellcolor{SpringGreen}  12& &\\ \cline{1-1}
\cellcolor{GreenYellow}  4 & &\\ \cline{1-1}
\cellcolor{SpringGreen} 55 & &\\ \cline{1-2}
\cellcolor{GreenYellow} 20 & \multicolumn{1}{|p{.5cm}|} {5} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}<0>[fragile]{Pilhas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\item {\color{red} Pilha Cheia!}
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen} 24 & &\\ \cline{1-1}
\cellcolor{GreenYellow}  89& &\\ \cline{1-1}
\cellcolor{SpringGreen}  12& &\\ \cline{1-1}
\cellcolor{GreenYellow}  4 & &\\ \cline{1-1}
\cellcolor{SpringGreen} 55 & &\\ \cline{1-2}
\cellcolor{GreenYellow} 20 & \multicolumn{1}{|p{.5cm}|} {5} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Pilhas Encadeadas}
\setbeamercovered{invisible}
\begin{columns}
\column{.25\textwidth}
		\begin{center}
			\begin{tikzpicture}[list/.style={rectangle,
	draw=black, fill=green!5,minimum width=0.75cm,
	minimum height = .5cm}, >=stealth, start chain]

\node<1>[list,on chain]  (B1)  {};
\node<1>[list,on chain] (B2) [below =0cm of B1] {};
\node<1>[list,on chain] (B5) [below =0cm of B4] {20};
\node<1>[list,on chain] (B4) [below =0cm of B3] {55};
\node<1>[list,on chain] (B3) [below =0cm of B2] {4};

\node<1>[] (L1) [left=.5cm of B5]{\color{red}Base da pilha};
\node<1>[] (L2) [left=.5cm of B3]{\color{red}Topo da pilha};
\draw<1>[red,->] (L1) -- (B5);
\draw<1>[red,->] (L2) -- (B3);

\end{tikzpicture}
\end{center}
\column{.75\textwidth}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal}, >=stealth, start chain]

  \node[list,on chain] (H) {3};
  \node at (2,0) (T) {\color{red}Cabeça};
  \draw [red,<-] (H) -- (T);
  \node[list,on chain] (A) [below right=of H] {};
  
  \node[draw,on chain] (E1) [left=of A]{4};
  
  
  \node (T2)[align=left,right=of A] {\color{red}{Topo da pilha}};
  \draw [red,<-] (A) -- (T2);
  
  
  \node[list,on chain] (B) [below =of A] {};
   \node[draw,on chain] (E2) [left=of B]{55};
  \node[list,on chain] (C) [below =of B] {};
    \node[draw,on chain] (E3) [left=of C]{20};
  
   \node (U1)[align=left,right=of B] {\color{red}Elemento};
   \draw [red,<-] (A) -- (U1); 
   \draw [red,<-] (B) -- (U1); 
   \draw [red,<-] (C) -- (U1); 
    
    
   \node (U2)[align=left,right=of C] {\color{red}{Base da pilha}};
  \draw [red,<-] (C) -- (U2.west); 
  
    
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) [below =of C] {null*};
  \node  (T3)[left=of D] {\color{red}Marcador Fim};
  \draw  [red,<-] (D) -- (T3);  
  \draw[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1,\y2) -- (A);
  \draw[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (B);
  \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1,\y2) -- (C);
  \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1,\y2) -- (D);

 \draw[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+5,\y2) -- (E1);  
\draw[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+5,\y2) -- (E2); 
\draw[*->] let \p1 = (C.one), \p2 = (C.center) in (\x1+5,\y2) -- (E3);
  
\end{tikzpicture}
\end{center}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Modelagem da Pilha}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Aspecto Estrutural:
\begin{itemize}
\item Mesmas estruturas de uma lista encadeada:
\begin{itemize}
\item Estrutura Lista
\item Estrutura Elemento
\item Ponteiro genérico de dados.
\end{itemize}
\end{itemize}
\end{itemize}
\end{frame}


\begin{frame}<0>[fragile]{Modelagem da Elemento de Pilha}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Aspecto Estrutural:
\begin{itemize}
\item Necessitamos um ponteiro para o próximo elemento da pilha;
\item Necessitamos um campo do tipo da informação que vamos armazenar.
\end{itemize}
\begin{lstlisting}
estrutura Elemento {
 Elemento *_proximo;
 T* _info;
};
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}<0>[fragile]{Modelagem da Elemento de Pilha}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Aspecto Estrutural:
\begin{itemize}
\item Necessitamos um ponteiro para o próximo elemento da pilha;
\item Necessitamos um ponteiro do tipo da informação que vamos armazenar.
\item T necessita de um destrutor próprio, assim como a pilha (neste caso a cabeça) vai precisar de um também;
\end{itemize}
\begin{lstlisting}
classe Elemento {
 Elemento *_proximo;
 T *_info;
};
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Modelagem da Pilha Encadeada}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Aspecto Funcional:
\begin{itemize}
\item Inicializar a pilha.
\item Empilhar (\textit{\textbf{push}}) dado na pilha;
\item Desempilhar (\textit{\textbf{pop}}) dado da pilha;
\item Testar se a pilha está vazia;

\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Modelagem da Pilha Encadeada}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Inicializar ou limpar:
\begin{itemize}
\item inicializarPilha();
\item destruirPilha()
\end{itemize}
\item Testar se a pilha está vazia:
\begin{itemize}
\item bool pilhaVazia();
\end{itemize}
\item Colocar e retirar dados da pilha:
\begin{itemize}
\item push();
\item pop();
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Método \textit{inicializarPilha}}
	\lstset{language=C++,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{OliveGreen}\ttfamily,
		breaklines=true,
		basicstyle=\ttfamily\footnotesize
	}
	\begin{itemize}
		\item Equivalente ao inicializarLista()
		\item Complexidade temporal $\Theta(1)$
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Método \textit{destruirPilha}}
	\lstset{language=C++,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{OliveGreen}\ttfamily,
		breaklines=true,
		basicstyle=\ttfamily\footnotesize
	}
	\begin{itemize}
		\item Similar a destruirLista;
		\item Função genérica em C não consegue desalocar qualquer tipo de dado na pilha
		\item Complexidade temporal $\Theta(n)$
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Método \textit{pilhaVazia}}
	\lstset{language=C++,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{OliveGreen}\ttfamily,
		breaklines=true,
		basicstyle=\ttfamily\footnotesize
	}
	\begin{itemize}
		\item Equivalente a verificar se o tamanho da lista é nulo
		\item Complexidade temporal $\Theta(1)$
	\end{itemize}      
\end{frame}

\begin{frame}[fragile]{Método \textit{push}}
	\begin{itemize}
		\item Equivalente a adicionaNoInicio na lista encadeada.
		\item Complexidade temporal $\Theta(1)$
	\end{itemize}	
\end{frame}	

%\begin{frame}[fragile]{Método \textit{empilha(T dado)}}
%\begin{columns}
%\column{.5\textwidth}
%\setbeamercovered{invisible}
%\begin{itemize}
%\item Testamos se é possível alocar um elemento;\pause
%\item Fazemos o próximo deste novo elemento ser o topo da pilha;\pause
%\item Fazemos a cabeça de pilha apontar para o novo elemento.\pause
%\item <9-> {\color{red}Semelhanças??}
%\end{itemize}
%\column{.5\textwidth}
%\begin{center}
%\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
%    draw=green!60, fill=green!5, rectangle split horizontal}, 
%    element/.style={rectangle, draw=yellow!60, fill=yellow!5,},    
%    >=stealth, start chain]
%
%  \node<8->[list] (H) {3};
%  \node<4-7>[list] (H) {2};
%  \node<5->[list,on chain] (A) [below right=of H] {};
%
%  \node<5->[list,draw=blue!60, fill=blue!5,on chain] (N) [right=of H] {Novo}; 
% 
%  \draw<5->[*->] let \p1 = (N.two), \p2 = (N.center) in (\x1+2,\y2) -- (A);  
%  
%  
%  \node<5->[element] (AP) [left=of A] {melão};
%  \draw<5->[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+4,\y2) -- (AP);
%  \draw<6->[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1+1,\y2+2) -- (B);
%  
%  \node<4>[list,on chain] (B) [below = of A] {};
%  \node<5->[list,on chain] (B) [below = of A] {};
%  
%  \draw<4-6>[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1,\y2) -- (B);
%  \draw<7->[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1,\y2) -- (A);
%  
%  
%  \node[list,on chain] (C) [below = of B] {};
%  \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1+1,\y2+2) -- (C);
%  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) [below = of C] {null*};
%  \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1+1,\y2+2) -- (D);
%  
%  \node[element] (BP) [left=of B] {maçã}; 
%  \draw[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+4,\y2) -- (BP);
%  \node[element] (CP) [left=of C] {uva};
%  \draw[*->] let \p1 = (C.one), \p2 = (C.center) in (\x1+4,\y2) -- (CP);
% 
%\end{tikzpicture}
%\end{center}
%\end{columns}
%\end{frame}

\begin{frame}<0>[fragile]{Método \textit{T desempilha()}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }
\setbeamercovered{invisible}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Testamos se há elementos;\pause
\item Decrementamos o tamanho;\pause
\item Liberamos a memória do elemento;\pause
\item Devolvemos a informação.\pause
\item <9-> {\color{red}Semelhanças??}
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    element/.style={rectangle, draw=yellow!60, fill=yellow!5,},    
    >=stealth, start chain]

  \node<5-6>[list] (H) {3};
  \node<7->[list,on chain] (H) {2};

  \node<6->[list,draw=blue!60, fill=blue!5,on chain] (V) [right=of H] {Volta}; 
  \draw<6->[*->] let \p1 = (V.two), \p2 = (V.center) in (\x1+3,\y2) -- (AP);  
    
  \node<5-7>[list,on chain] (A) [below right=of H] {};
  \draw<5-7>[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+4,\y2) -- (AP);
  \node<5-8>[element] (AP) [left=of A] {melão};
  \draw<5-7>[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1+1,\y2+2) -- (B);

  \node<6-8>[list,draw=blue!60, fill=blue!5,on chain] (S) [right=of A] {\nodepart{two} Saiu}; 
  \draw<6-8>[*->] let \p1 = (S.one), \p2 = (S.center) in (\x1+4,\y2) -- (A);  

  
  \node<7->[list,on chain] (B) [below=of A] {};
  \node<5-6>[list,on chain] (B) [below=of A]{};
  
  \draw<7->[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1,\y2+2) -- (B);
  \draw<5-6>[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1,\y2+2) -- (A);
  
  
  \node[list,on chain] (C)[below=of B] {};
  \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1+1,\y2+2) -- (C);
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) [below=of C] {null*};
  \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1+1,\y2+2) -- (D);
  
  \node[element] (BP) [left=of B] {maçã}; 
  \draw[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+4,\y2) -- (BP);
  \node[element] (CP) [left=of C] {uva};
  \draw[*->] let \p1 = (C.one), \p2 = (C.center) in (\x1+4,\y2) -- (CP);
 
\end{tikzpicture}
\end{center}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Método \textit{pop}}
	\begin{itemize}
		\item Equivalente a retiraNoInicio na lista encadeada.
		\item Complexidade temporal $\Theta(1)$
	\end{itemize}	
\end{frame}	

\begin{frame}[fragile]{Aplicações de Pilhas}
\begin{enumerate}
	\item Algoritmos de Busca em Profundidade com \textit{Backtracking} 
	\begin{itemize}
		\item Busca pela saída em labirintos
	\end{itemize}
	\item Chamada e retorno de funções na execução de um software
	\item Mais exemplos \tiny\url{http://jcsites.juniata.edu/faculty/kruse/cs240/stackapps.htm}
\end{enumerate}
\end{frame}

\begin{frame}<0>[fragile]{Trabalho Pilha Encadeada}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }
\begin{itemize}
\item Implemente uma classe Pilha todas as operações vistas;
\item Implemente a pilha usando Templates;
\item Use as melhores práticas de orientação a objetos;
\item Documente todas as classes, métodos e atributos;
\item Aplique os testes unitários disponíveis no moodle da disciplina para validar sua estrutura de dados;
\item Entregue até a data definida no moodle.
\end{itemize}
\end{frame}


%%%%
\begin{frame}[fragile]{Conceito de Pilhas}
	\setbeamercovered{invisible}
	\begin{columns}
		\column{.5\textwidth}
		
		
\begin{block}{Fila}
	É uma estrutura de dados cujo funcionamento é inspirado no conceito “natural” de enfileiramento, onde o \color{blue}{primeiro a entrar é o primeiro a sair} \color{black}(FIFO = \textit{first in, first out}).
\end{block}
		
		\column{.5\textwidth}
		\begin{center}
			\begin{tikzpicture}[list/.style={rectangle,
				draw=black, fill=green!5,minimum width=0.75cm,
				minimum height = .75cm}, >=stealth, start chain]
			
			\node<1-7>[list,on chain]  (B1)  {{\uncover<3-7>{20}}};
			\node<1-8>[list,on chain] (B2) [right =0cm of B1] {{\uncover<4-8>{55}}};
			\node<1-9>[list,on chain] (B3)  [right =0cm of B2] {{\uncover<5-9>{4}}};
			\node<1-10>[list,on chain] (B4)  [right =0cm of B3] {{\uncover<6-10>{12}}};
			\node<1-11>[list,on chain] (B5) [right =0cm of B4] {{\uncover<7-11>{7}}};
			\node<1>[] (PV) [above= of B3] {Fila Vazia};
			
			\node<2>[] (C1) [below = of B3] {Enfilerar 20};
			\draw<2>[->] (C1.north) to [out=90, in=270] (B1.center);
			
			\node<3>[] (C1) [below = of B3] {Enfilerar 55};
			\draw<3>[->] (C1.north) to [out=90, in=270] (B2.center);

			\node<4>[] (C1) [below = of B3] {Enfilerar 4};
			\draw<4>[->] (C1.north) to [out=90, in=270] (B3.center);

			\node<5>[] (C1) [below = of B3] {Enfilerar 12};
			\draw<5>[->] (C1.north) to [out=90, in=270] (B4.center);
			
			\node<6>[] (C1) [below = of B3] {Enfilerar 7};
			\draw<6>[->] (C1.north) to [out=90, in=270] (B5.center);

			\node<7>[] (C1) [below = of B3] {Desenfilerar 20};
			\draw<7>[<-] (C1.north) to [out=90, in=270] (B1.south);

			\node<8->[list,on chain] (B6) [right =0cm of B5] {};
			\node<8>[] (C1) [below = of B4] {Desenfilerar 55};
			\draw<8>[<-] (C1.north) to [out=90, in=270] (B2.south);

			\node<9->[list,on chain] (B7) [right =0cm of B6] {};
			\node<9>[] (C1) [below = of B5] {Desenfilerar 4};
			\draw<9>[<-] (C1.north) to [out=90, in=270] (B3.south);
			
			\node<10->[list,on chain] (B8) [right =0cm of B7] {};
			\node<10>[] (C1) [below = of B6] {Desenfilerar 12};
			\draw<10>[<-] (C1.north) to [out=90, in=270] (B4.south);

			\node<11->[list,on chain] (B9) [right =0cm of B8] {};
			\node<11>[] (C1) [below = of B7] {Desenfilerar 7};
			\draw<11>[<-] (C1.north) to [out=90, in=270] (B5.south);

			\node<12>[] (PV) [above= of B7] {Fila Vazia};

			%\node<4-11>[list,on chain] (B4) [below =0cm of B3] {55};
			%\node<4>[] (C1) [above left= of B1] {Empilhar 4};
			%\draw<4>[->] (C1.east) to [out=45, in=90] (B3.center);
			
			%\node<5-10>[list,on chain] (B3) [below =0cm of B2] {4};
			%\node<5>[] (C1) [above left= of B1] {Empilhar 12};
			%\draw<5>[->] (C1.east) to [out=45, in=90] (B2.center);
			
			%\node<6-9>[list,on chain] (B2) [below =0cm of B1] {12};
			%\node<6>[] (C1) [above left= of B1] {Empilhar 7};
			%\draw<6>[->] (C1.east) to [out=45, in=90] (B1.center);
			
			%\node<7-8>[list,on chain] (B1) [above =0cm of B2] {7};
			%\node<8>[] (D1) [above right= of B1] {Desempilhar 7};
			%\draw<8>[->] (B1.north) to [out=90, in=180] (D1.west);
			
			%\node<9>[] (D1) [above right= of B1] {Desempilhar 12};
			%\draw<9>[->] (B2.north) to [out=90, in=180] (D1.west);
			
			%\node<10>[] (D1) [above right= of B1] {Desempilhar 4};
			%\draw<10>[->] (B3.north) to [out=90, in=180] (D1.west);
			
			%\node<11>[] (D1) [above right= of B1] {Desempilhar 55};
			%\draw<11>[->] (B4.north) to [out=90, in=180] (D1.west);			
			
			%\node<12>[] (D1) [above right= of B1] {Desempilhar 20};
			%\draw<12>[->] (B5.north) to [out=90, in=180] (D1.west);			
			
			\end{tikzpicture}
		\end{center}
	\end{columns}
\end{frame}





\begin{frame}{Conceito de Filas}
\begin{columns}
\column{.5\textwidth}
\begin{block}{Fila}
É uma estrutura de dados cujo funcionamento é inspirado no conceito “natural” de enfileiramento, onde o primeiro a entrar é o primeiro a sair (FIFO).
\end{block}
\column{.5\textwidth}
\begin{center}
{\rowcolors{1}{SpringGreen}{GreenYellow}
\begin{tabular}{ |p{.5cm}|p{.5cm}|p{.5cm}|p{.5cm}|p{.5cm}|p{.5cm}| }
\hline
& & 24 & 89 & 12 & 4  \\ \hline
\end{tabular}
}
\end{center}
\begin{itemize}
\item Duas operações:
\begin{itemize}
\item {\color{red}Incluir no Fim};
\item {\color{red}Retirar do Inicio};
\end{itemize}
\end{itemize}
\end{columns}
\end{frame}

\begin{frame}<0>[fragile]{Filas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\item Incluímos sempre no fim.
\item {\color{red}Fila Cheia!}
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen} 24 & &\\ \cline{1-1}
\cellcolor{GreenYellow}  89& &\\ \cline{1-1}
\cellcolor{SpringGreen}  12& &\\ \cline{1-1}
\cellcolor{GreenYellow}  4 & &\\ \cline{1-1}
\cellcolor{SpringGreen} 55 & &\\ \cline{1-2}
\cellcolor{GreenYellow} 20 & \multicolumn{1}{|p{.5cm}|} {5} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Modelagem de Fila Encadeada}
\setbeamercovered{invisible}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    queue/.style={rectangle split, rectangle split parts=3,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    element/.style={rectangle, draw=yellow!60, fill=yellow!5,},    
    >=stealth, start chain]

  \node[queue,on chain] (H) {3};
  \node[list,on chain] (A) [below=of H] {};
  \draw[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1+2,\y2+2) -- (A);
  \node[list,on chain] (B) {};
  \draw[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (B);
  \node[list,on chain] (C) {};
  \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1,\y2) -- (C);
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) {null*};
  \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1,\y2) -- (D);
  \draw[*->] let \p1 = (H.three), \p2 = (H.center) in (\x1,\y2) -- (D);
  \node[element] (AP) [below=of A] {melão};
  \draw[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+2,\y2+2) -- (AP);
  \node[element] (BP) [below=of B] {maçã};
  \draw[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+2,\y2+2) -- (BP);
  \node[element] (CP) [below=of C] {uva};
  \draw[*->] let \p1 = (C.one), \p2 = (C.center) in (\x1+2,\y2+2) -- (CP);
 
\end{tikzpicture}
\end{center}
\end{frame}


\begin{frame}[fragile]{Modelagem da Cabeça de Fila Encadeada}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Aspecto Estrutural:
\begin{itemize}
\item Necessitamos um ponteiro para o primeiro elemento da fila;
\item Necessitamos um ponteiro para o Ultimo elemento da fila;
\item Necessitamos um inteiro para indicar quantos elementos a fila possui.
\end{itemize}
\begin{lstlisting}
classe Lista {
 Elemento *_dados;
 Elemento *_fim;
 inteiro _tamanho;
};
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Método \textit{Fila()}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Inicializamos o ponteiro para \_dados nulo;
\item Inicializamos o ponteiro para \_fim nulo;
\item Inicializamos o tamanho para ``0'';
\end{itemize}
\begin{lstlisting}
Fila()
inicio
  _dados = null;
  _fim = null;
  _tamanho <- 0;
fim;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Método \textit{adiciona(T dado)}}
\setbeamercovered{invisible}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    queue/.style={rectangle split, rectangle split parts=3,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    element/.style={rectangle, draw=yellow!60, fill=yellow!5,},    
    >=stealth, start chain]

  %cabeca
  \node<6->[queue] (H) {3};
  \node<1-5>[queue] (H) {2};
  \draw[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1+2,\y2+2) -- (A);
  \draw<5->[*->] let \p1 = (H.three), \p2 = (H.center) in (\x1,\y2) -- (C);  
  \draw<1-4>[*->] let \p1 = (H.three), \p2 = (H.center) in (\x1,\y2) -- (B);

  %novo
  \node<2->[list,draw=blue!60, fill=blue!5,on chain] (N) [above right=of H] {Novo}; 
  \draw<2->[*->] let \p1 = (N.two), \p2 = (N.center) in (\x1+2,\y2+2) -- (C);  
  
  %primeiro elemento
  \node[list,on chain] (A) [below=of H] {};
  \node[list,on chain] (B) {};
  \node<2->[list,on chain] (C) {};
  %dados 
  \draw[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+2,\y2+2) -- (AP);
  \node[element] (AP) [below=of A] {melão};
  %ponteiros
  \draw[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (B);
  
  
   %segundo elemento
  %dados
  \draw[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+2,\y2+2) -- (BP);
  \node[element] (BP) [below=of B] {maçã}; 
  %ponteiro
  \draw<4->[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1,\y2) -- (C);
  \draw<1-3>[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1+2,\y2-2) .. controls +(north:20mm) and +(up:10mm)  .. (D.north);
  
  %terceiro elemento  
  
  %dados
  \node<2->[element] (CP) [below=of C] {uva};
  \draw<2->[*->] let \p1 = (C.one), \p2 = (C.center) in (\x1+2,\y2+2) -- (CP);
   %null pointer
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) [right=of C]{null*};
  %ponteiro
  \draw<3->[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1,\y2) -- (D);
  
\end{tikzpicture}
\end{center}
\begin{itemize}
\item <7>{\color{red}Semelhanças??}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Método \textit{adiciona(T dado)} - Caso Especial Fila Vazia}
\setbeamercovered{invisible}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    queue/.style={rectangle split, rectangle split parts=3,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    element/.style={rectangle, draw=yellow!60, fill=yellow!5,},    
    >=stealth, start chain]

  %cabeca
  \node<1-5>[queue] (H) {0};
  \node<6->[queue] (H) {1};
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) [below right=of H]{null*};
    %primeiro elemento
  \node<2->[list,on chain] (A) [below=of H] {};
  %dados 
  \draw<2->[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+2,\y2+2) -- (AP);
  \node<2->[element] (AP) [below=of A] {melão};
  \draw<1-3>[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1,\y2) -- (D);
  \draw<1-4>[*->] let \p1 = (H.three), \p2 = (H.center) in (\x1,\y2) -- (D);
  \draw<3->[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (D);
  \draw<4->[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1,\y2) -- (A);
  \draw<5->[*->] let \p1 = (H.three), \p2 = (H.center) in (\x1,\y2) -- (A);
  %novo
  \node<2->[list,draw=blue!60, fill=blue!5,on chain] (N) [left=of A] {Novo}; 
  \draw<2->[*->] let \p1 = (N.two), \p2 = (N.center) in (\x1,\y2) -- (A);  
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}[fragile]{Método \textit{adiciona(T dado)}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          escapeinside={(*@}{@*)},
          basicstyle=\ttfamily\scriptsize
          }
\begin{lstlisting}
adicionaNaPosicao(T dado, int posicao)
 Elemento *novo; // auxiliar.
 inicio
  novo <- aloque(Elemento);
  SE ( novo == NULO) THROW(ERROFILACHEIA);
   SE filaVazia() ENTAO
    _dados <- novo
   SENAO
    _fim->_proximo <- novo;
   FIM SE
   novo->_proximo <- NULO;
   novo->_info <- dado;
   _fim <- novo;
   _tamanho <- _tamanho + 1;
  FIM SE
fim;
(*@  \textcolor{red}{}  @*)
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Método \textit{T retira()}}
\setbeamercovered{invisible}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    queue/.style={rectangle split, rectangle split parts=3,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    element/.style={rectangle, draw=yellow!60, fill=yellow!5,},    
    >=stealth, start chain]

  \node<1-2>[queue] (H) {3};
  \node<3->[queue,on chain] (H) {2};

  \node<2-4>[list,draw=blue!60, fill=blue!5,on chain] (S) [below left=of H] {Saiu}; 
  \draw<2-4>[*->] let \p1 = (S.two), \p2 = (S.center) in (\x1,\y2) -- (A);  
  
  \node<2->[list,draw=blue!60, fill=blue!5,on chain] (V) [left=of AP] {Volta}; 
  \draw<2->[*->] let \p1 = (V.two), \p2 = (V.center) in (\x1,\y2) -- (AP);  
  
  \node<1-3>[list,on chain] (A) [below=of H] {};
  \draw<1-3>[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+2,\y2+2) -- (AP);
  \node<1-4>[element] (AP) [below=of A] {melão};
  \draw<1-3>[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (B);
  
  \node<3->[list,on chain] (B) [below right=of H] {};
  \node<1-2>[list,on chain] (B) {};
  
  \draw<3->[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1+2,\y2+2) -- (B);
  \draw<1-2>[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1+2,\y2+2) -- (A);
  
  
  \node[list,on chain] (C) {};
  \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1,\y2) -- (C);
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) {null*};
  \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1,\y2) -- (D);
  \draw<1->[*->] let \p1 = (H.three), \p2 = (H.center) in (\x1+2,\y2+2) -- (C);
  
  \node[element] (BP) [below=of B] {maçã}; 
  \draw[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+2,\y2+2) -- (BP);
  \node[element] (CP) [below=of C] {uva};
  \draw[*->] let \p1 = (C.one), \p2 = (C.center) in (\x1+2,\y2+2) -- (CP);
 
\end{tikzpicture}
\end{center}
\begin{itemize}
\item <5-> {\color{red}Semelhanças??}
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Método \textit{T retira()} - Caso Especial Fila Unitária}
\setbeamercovered{invisible}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    queue/.style={rectangle split, rectangle split parts=3,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    element/.style={rectangle, draw=yellow!60, fill=yellow!5,},    
    >=stealth, start chain]

  %cabeca
  \node[queue] (H) {0};
  \node[queue] (H) {1};
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) [below right=of H]{null*};
    %primeiro elemento
  \node<1-2>[list,on chain] (A) [below=of H] {};
  %dados 
  \draw<1-2>[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+2,\y2+2) -- (AP);
  \node[element] (AP) [below=of A] {melão};
  \draw<4->[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1,\y2) -- (D);
  \draw<4->[*->] let \p1 = (H.three), \p2 = (H.center) in (\x1,\y2) -- (D);
  \draw<1-2>[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (D);
  \draw<1-3>[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1,\y2) -- (A);
  \draw<1-3>[*->] let \p1 = (H.three), \p2 = (H.center) in (\x1,\y2) -- (A);
  %novo
  \node<2->[list,draw=blue!60, fill=blue!5,on chain] (N) [left=of AP] {Volta}; 
  \draw<2->[*->] let \p1 = (N.two), \p2 = (N.center) in (\x1,\y2) -- (AP);  
\end{tikzpicture}
\end{center}
\end{frame}


\begin{frame}[fragile]{Método \textit{T retira()}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          escapeinside={(*@}{@*)},
          basicstyle=\ttfamily\scriptsize
          }
\begin{lstlisting}
T retira()
 Elemento *saiu; //Variável auxiliar elemento.
 T *volta; //Variável auxiliar tipo T.
	início
		SE (listaVazia()) ENTAO
		  THROW(ERROLISTAVAZIA);
		SENAO
		  saiu <- _dados;
		  volta <- saiu->_info;
		  _dados <- saiu->_próximo;
          //Se SAIU for o único, próximo é NULO e está certo.
          SE (_tamanho = 1) ENTAO
           //Fila unitária: devo anular o _fim também.
           _fim <- NULO;
          FIM SE
		  _tamanho <- _tamanho - 1;
		  LIBERE(saiu);
		  RETORNE(volta);
		FIM SE
	fim;
(*@  \textcolor{red}{}  @*)
\end{lstlisting}
\end{frame}

\begin{frame}{Aplicações de Filas}
	\begin{itemize}
		\item É importante para gerência de dados/processos por ordem cronológica:
		\begin{itemize}
			\item Fila de impressão em uma impressora de rede;
			\item Fila de pedidos de uma expedição ou tele-entrega;
		\end{itemize}
		\item É importante para simulação de processos sequenciais:
		\begin{itemize}
			\item chão de fábrica: fila de camisetas a serem estampadas;
			\item comércio: simulação de fluxo de um caixa de supermercado;
			\item tráfego: simulação de um cruzamento com um semáforo.
		\end{itemize}
	\end{itemize}
\end{frame}



\begin{frame}[fragile]{Trabalho Fila Encadeada}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }
\begin{itemize}
\item Implemente uma classe Fila todas as operações vistas;
\item Implemente a fila usando Templates;
\item Use as melhores práticas de orientação a objetos;
\item Documente todas as classes, métodos e atributos;
\item Aplique os testes unitários disponíveis no moodle da disciplina para validar sua estrutura de dados;
\item Entregue até a data definida no moodle.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Listas Duplamente Encadeadas}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }
\begin{itemize}
\item A Lista Encadeada e a Fila Encadeada possuem a desvantagem de somente podermos caminhar em uma direção:
\begin{itemize}
\item Vimos que para olhar um elemento pelo qual ``acabamos de passar'' precisamos de uma variável auxiliar ``anterior'';
\item Para olhar outros elementos ainda anteriores não temos nenhum meio, a não ser começar de novo.
\end{itemize}
\item A Lista Duplamente Encadeada é uma estrutura de lista que permite deslocamento em ambos os sentidos:
\begin{itemize}
\item Útil para representar conjuntos de eventos ou objetos a serem percorridos em dois sentidos;
\item Útil também quando realizamos uma busca aproximada e nos movemos para a frente e para trás.
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Lista Duplamente Encadeada}
\setbeamercovered{invisible}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal},
    double/.style={rectangle split, rectangle split parts=3,
    draw=green!60, fill=green!5, rectangle split horizontal},  
    element/.style={rectangle, draw=yellow!60, fill=yellow!5,},    
    >=stealth, start chain]

  \node[list,on chain] (H) {3};
  \node[double,on chain] (A) [below=of H] {};
  \node[double,on chain] (B) {};
  \node[double,on chain] (C) {};
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) {null*};
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D2)[left=of A] {null*};
  
  
  \draw[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1+2,\y2+2) -- (A);
  \draw[*->] let \p1 = (A.three), \p2 = (A.center) in (\x1,\y2+2) -- (B);
  \draw[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+4,\y2-2) -- (D2);
  \draw[*->] let \p1 = (B.three), \p2 = (B.center) in (\x1,\y2+2) -- (C);
  \draw[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+4,\y2-2) -- (A);
  \draw[*->] let \p1 = (C.three), \p2 = (C.center) in (\x1,\y2+2) -- (D);
  \draw[*->] let \p1 = (C.one), \p2 = (C.center) in (\x1+4,\y2-2) -- (B);


  \node[element] (AP) [below=of A] {melão};
  \draw[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1+2,\y2+2) -- (AP);
  \node[element] (BP) [below=of B] {maçã};
  \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1+2,\y2+2) -- (BP);
  \node[element] (CP) [below=of C] {uva};
  \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1+2,\y2+2) -- (CP);
 
\end{tikzpicture}
\end{center}
\end{frame}


\begin{frame}[fragile]{Modelagem da Cabeça de Lista Dupla}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Aspecto Estrutural:
\begin{itemize}
\item Necessitamos um ponteiro para o primeiro elemento da lista;
\item Necessitamos um inteiro para indicar quantos elementos a lista possui.
\end{itemize}
\begin{lstlisting}
classe ListaDupla {
 ElementoDuplo *_dados;
 inteiro _tamanho;
};
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Modelagem da Elemento de Lista Dupla}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Aspecto Estrutural:
\begin{itemize}
\item Necessitamos um ponteiro para o próximo elemento;
\item Necessitamos um ponteiro para o elemento anterior;
\item Necessitamos um ponteiro do tipo da informação que vamos armazenar.
\item T necessita de um destrutor próprio, assim como a lista (neste caso a cabeça) vai precisar de um também;
\end{itemize}
\begin{lstlisting}
classe ElementoDuplo {
 Elemento *_proximo;
 Elemento *_anterior;
 T *_info;
};
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Modelagem da Lista Duplamente Encadeada}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Aspecto Funcional:
\begin{itemize}
\item Temos que colocar e retirar dados da lista;
\item Temos que testar se a lista está vazia (dentre outros testes);
\item Temos que inicializar a lista e garantir a ordem de seus elementos.
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Modelagem da Lista Duplamente Encadeada}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Inicializar ou limpar:
\begin{itemize}
\item ListaDupla();
\item limpaListaDupla();
\item \~{}ListaDupla();
\end{itemize}
\item Testar se a lista está vazia ou cheia e outros testes:
\begin{itemize}
\item bool listaVaziaDupla();
\item int posicaoDupla(dado);
\item bool contemDupla(dado);
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Modelagem da Lista Duplamente Encadeada}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Colocar e retirar dados da lista:
\begin{itemize}
\item adicionaDupla(T dado);
\item adicionaNoInicioDupla(T dado);
\item adicionaNaPosicaoDupla(T dado, int posicao);
\item adicionaEmOrdemDupla(T dado);
\item T retiraDupla();
\item T retiraDoInicioDupla();
\item T retiraDaPosicaoDupla(int posicao);
\item T retiraEspecificoDupla(dado);
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Método \textit{ListaDupla()}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Inicializamos o ponteiro para nulo;
\item Inicializamos o tamanho para ``0'';
\end{itemize}
\begin{lstlisting}
ListaDupla()
inicio
  _dados = null;
  _tamanho <- 0;
fim;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Método \textit{\~{}ListaDupla()}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Chamamos DestroiLista();
\end{itemize}
\begin{lstlisting}
~ListaDupla()
inicio
  DestroiListaDupla();
fim;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Método \textit{listaVaziaDupla()}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }
\begin{lstlisting}
bool listaVaziaDupla()
inicio
SE (_tamanho = 0) ENTAO
 RETORNE(Verdadeiro)
SENAO
 RETORNE(Falso);
fim;
\end{lstlisting}
\begin{itemize}
\item Um algoritmo ListaCheia não existe na Lista Duplamente Encadeada;\pause
\item Verificar se houve espaço na memória para um novo elemento será responsabilidade de cada operação de adição.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Método \textit{adicionaNoInicioDupla(T dado)}}
\setbeamercovered{invisible}
\begin{itemize}
\item Testamos se é possível alocar um elemento;\pause
\item Fazemos o próximo deste novo elemento ser o primeiro;\pause
\item Fazemos a cabeça de lista apontar para o novo elemento.\pause
\end{itemize}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal},
    double/.style={rectangle split, rectangle split parts=3,
    draw=green!60, fill=green!5, rectangle split horizontal},  
    element/.style={rectangle, draw=yellow!60, fill=yellow!5,},    
    >=stealth, start chain]

  \node<10>[list] (H) {3};
  \node<4-9>[list] (H) {2};
  \node<5->[double,on chain] (A) [below=of H] {};
  \node[double,on chain] (B) [below right=of H]{};
  \node[double,on chain] (C) {};
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) {null*};
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D2)[left=of A] {null*};

  \node<5->[list,draw=blue!60, fill=blue!5,on chain] (N) [left=of H] {Novo}; 
  \draw<5->[*->] let \p1 = (N.two), \p2 = (N.center) in (\x1,\y2) -- (A);  
  
  
  \draw<9->[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1+2,\y2+2) -- (A);
  \draw<-8>[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1+2,\y2+2) -- (B);
  \draw<6->[*->] let \p1 = (A.three), \p2 = (A.center) in (\x1,\y2+2) -- (B);
  \draw<7->[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+4,\y2-2) -- (D2);
  \draw[*->] let \p1 = (B.three), \p2 = (B.center) in (\x1,\y2+2) -- (C);
  \draw<8->[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+4,\y2-2) -- (A);
  \draw<-4>[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+4,\y2-2) -- (D2);
  \draw[*->] let \p1 = (C.three), \p2 = (C.center) in (\x1,\y2+2) -- (D);
  \draw[*->] let \p1 = (C.one), \p2 = (C.center) in (\x1+4,\y2-2) -- (B);
  \draw<5-7>[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+2,\y2) .. controls +(south:40mm) and +(down:25mm)  .. (D2.south);


  \node<5->[element] (AP) [below=of A] {melão};
  \draw<5->[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1+2,\y2+2) -- (AP);
  \node[element] (BP) [below=of B] {maçã};
  \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1+2,\y2+2) -- (BP);
  \node[element] (CP) [below=of C] {uva};
  \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1+2,\y2+2) -- (CP);
 
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}[fragile]{Método \textit{adicionaNoInicioDupla(T dado)}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          escapeinside={(*@}{@*)},
          basicstyle=\ttfamily\footnotesize
          }
\begin{lstlisting}
adicionaNoInicioDupla(T dado)
 ElementoDuplo *novo; //Variável auxiliar.
 início
  novo <- aloque(ElementoDuplo);
  SE (novo = NULO) ENTAO
   THROW(ERROLISTACHEIA);
  SENAO
   novo->_proximo <- _dados;
   novo->_anterior <- NULO;
   novo->_info <- dado;
   _dados <- novo;
   SE (novo->_proximo ~= NULO) ENTAO
    novo->_proximo->_anterior <- novo;
   FIM SE;
   _tamanho <- _tamanho + 1;
  FIM SE
  fim;
(*@  \textcolor{red}{}  @*)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Método \textit{T retiraDoInicioDupla()}}
\setbeamercovered{invisible}
\begin{itemize}
\item Testamos se há elementos;\pause
\item Decrementamos o tamanho;\pause
\item Liberamos a memória do elemento;\pause
\item Devolvemos a informação.\pause
\end{itemize}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal},
    double/.style={rectangle split, rectangle split parts=3,
    draw=green!60, fill=green!5, rectangle split horizontal},  
    element/.style={rectangle, draw=yellow!60, fill=yellow!5,},    
    >=stealth, start chain]

  \node[list] (H) {3};
  \node<10->[list] (H) {2};
  \node<-8>[double,on chain] (A) [below=of H] {};
  \node[double,on chain] (B) [below right=of H]{};
  \node[double,on chain] (C) {};
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) {null*};
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D2)[left=of A] {null*};

  \node<6->[list,draw=blue!60, fill=blue!5,on chain] (N) [left=of H] {Saiu}; 
  \draw<6->[*->] let \p1 = (N.two), \p2 = (N.center) in (\x1,\y2) -- (A);  
  \node<6->[list,draw=blue!60, fill=blue!5,on chain] (V) [left=of AP] {Volta}; 
  \draw<6->[*->] let \p1 = (V.two), \p2 = (V.center) in (\x1,\y2) -- (AP);  
  
  
  \draw<-7>[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1+2,\y2+2) -- (A);
  \draw<8->[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1+2,\y2+2) -- (B);
  \draw<-8>[*->] let \p1 = (A.three), \p2 = (A.center) in (\x1,\y2+2) -- (B);
  \draw<-8>[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+4,\y2-2) -- (D2);
  \draw[*->] let \p1 = (B.three), \p2 = (B.center) in (\x1,\y2+2) -- (C);
  \draw<-6>[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+4,\y2-2) -- (A);
  \draw<9->[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+4,\y2-2) -- (D2);
  \draw[*->] let \p1 = (C.three), \p2 = (C.center) in (\x1,\y2+2) -- (D);
  \draw[*->] let \p1 = (C.one), \p2 = (C.center) in (\x1+4,\y2-2) -- (B);
  \draw<7-8>[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+2,\y2) .. controls +(south:40mm) and +(down:25mm)  .. (D2.south);


  \node[element] (AP) [below=of A] {melão};
  \draw<-8>[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1+2,\y2+2) -- (AP);
  \node[element] (BP) [below=of B] {maçã};
  \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1+2,\y2+2) -- (BP);
  \node[element] (CP) [below=of C] {uva};
  \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1+2,\y2+2) -- (CP);
 
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}[fragile]{Método \textit{T retiraDoInicioDupla()}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          escapeinside={(*@}{@*)},
          basicstyle=\ttfamily\scriptsize
          }
\begin{lstlisting}
T retiraDoInicioDupla()
 ElementoDuplo *saiu; //Variável auxiliar elemento.
 T *volta; //Variável auxiliar tipo T.
	início
		SE (listaVaziaDupla()) ENTAO
		  THROW(ERROLISTAVAZIA);
		SENAO
		  saiu <- _dados;
		  volta <- saiu->_info;
		  _dados <- saiu->_proximo;
		  SE (_dados ~= NULO) ENTAO
			dados->_anterior <- NULO;
		  FIM SE
		  _tamanho <- _tamanho - 1;
		  LIBERE(saiu);
		  RETORNE(volta);
		FIM SE
	fim;
(*@  \textcolor{red}{}  @*)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Método \textit{adicionaNaPosicaoDupla(T dado, int posicao)}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Praticamente idêntico à lista encadeada;
\item Procedimento:
\begin{itemize}
\item Caminhamos até a posição;
\item Adicionamos o novo dado na posição;
\item Tratamos o caso especial;
\item Incrementamos o tamanho.
\end{itemize}
\item Parâmetros:
\begin{itemize}
\item O dado a ser inserido;
\item A posição onde inserir;
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Método \textit{adicionaNaPosicaoDupla(T dado, int posicao)}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          escapeinside={(*@}{@*)},
          basicstyle=\ttfamily\scriptsize
          }
\begin{lstlisting}
adicionaNaPosicaoDupla(T dado, int posicao)
 ElementoDuplo *novo, *anterior; // auxiliares.
 inicio
  SE (posicao > _tamanho + 1) ENTAO THROW(ERROPOSICAO);
  SENAO
   SE (posicao = 1) ENTAO RETORNE(adicionaNoInícioDupla(info));
   SENAO
    novo <- aloque(ElementoDuplo); 
    SE (novo = NULO) ENTÃO THROW(ERROLISTACHEIA);
    SENAO
     anterior <- _dados;
     REPITA (posicao - 2) VEZES anterior <- anterior->_proximo;
     novo->_proximo <- anterior->_proximo;
     SE (novo->_proximo ~= NULO) ENTAO  
      novo->_proximo->_anterior <- novo; 
     novo->_info <- info;
     anterior->_proximo <- novo;
     _tamanho <- _tamanho + 1;
    FIM SE
   FIM SE
  FIM SE
fim;
(*@  \textcolor{red}{}  @*)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Método \textit{T retiraDaPosicaoDupla(int posicao)}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Praticamente idêntico à lista encadeada;
\item Procedimento:
\begin{itemize}
\item Caminhamos até a posição;
\item Retiramos o novo dado na posição;
\item Tratamos o caso especial;
\item Decrementamos o tamanho.
\end{itemize}
\item Parâmetros:
\begin{itemize}
\item A posição onde retirar;
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Método \textit{T retiraDaPosicaoDupla(int posicao)}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          escapeinside={(*@}{@*)},
          basicstyle=\ttfamily\scriptsize
          }
\begin{lstlisting}
T retiraDaPosicaoDupla(int posicao)
 ElementoDuplo *anterior, *eliminar; //Variáveis elemento.
 T *volta; //Variável tipo T.
 inicio
  SE (posicao > _tamanho ) ENTAO THROW(ERROPOSICAO);
  SENAO
   SE (posicao = 1) ENTAO RETORNE(retiraDoInicioDupla());
   SENAO
    anterior <- _dados;
    REPITA (posicao - 2) VEZES 
      anterior <- anterior->_proximo;
    eliminar <- anterior->_proximo;
    volta <- eliminar->_info;
    anterior->_proximo <- eliminar->_proximo;
    SE eliminar->_proximo ~= NULO ENTAO
     eliminar->_proximo->_anterior <- anterior;
    _tamanho <- _tamanho - 1;
    LIBERE(eliminar);  RETORNE(volta);
   FIM SE
  FIM SE
 fim;
(*@  \textcolor{red}{}  @*)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Método \textit{adicionaEmOrdemDupla(T dado)}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Idêntico à lista encadeada;
\item Procedimento:
\begin{itemize}
\item Necessitamos de uma função para comparar os dados ``>'';
\item Procuramos pela posição onde inserir comparando dados;
\item Chamamos adicionaNaPosiçãoDupla().
\end{itemize}
\item Parâmetros:
\begin{itemize}
\item O dado a ser inserido;
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Por conta do aluno:}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Operações de inclusão e exclusão:
\begin{itemize}
\item AdicionaDupla(dado);
\item RetiraDupla();
\item RetiraEspecíficoDupla(dado);
\end{itemize}
\item Operações - inicializar ou limpar:
\begin{itemize}
\item DestróiListaDupla();
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Trabalho Lista Duplamente Encadeada}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }
\begin{itemize}
\item Implemente uma classe ListaDupla todas as operações vistas;
\item Implemente a lista usando Templates;
\item Use as melhores práticas de orientação a objetos;
\item Documente todas as classes, métodos e atributos;
\item Aplique os testes unitários disponíveis no moodle da disciplina para validar sua estrutura de dados;
\item Entregue até a data definida no moodle.
\end{itemize}
\end{frame}

{
\usebackgroundtemplate{\includegraphics[width=\paperwidth,
height=\paperheight]{../reusable_images/fundo_capa.png}}
\begin{frame}

{\LARGE Perguntas????}

\end{frame}
}


{
\usebackgroundtemplate{\includegraphics[width=\paperwidth,
height=\paperheight]{../reusable_images/fundo_capa.png}}
\begin{frame}
\includegraphics[scale=0.8]{../reusable_images/cc_logo_arge.png}\hspace{0.5cm}
\includegraphics[scale=0.95]{../reusable_images/by.png}

\vspace{1cm}
Este trabalho está licenciado sob uma Licença Creative Commons Atribuição 4.0 Internacional. Para ver uma cópia desta licença, visite http://creativecommons.org/licenses/by/4.0/.

\end{frame}
}
\end{document}
